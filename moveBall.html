<div id="balls"></div>

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/Etc2by17Fe8"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

<script>
  // The original remit was to create a ball that bounced in a limited space, by using setInterval
  // I upgraded things a bit.

  var numberBalls = 22; // set this to the number of balls you would like to generate (potentially later request input here?)

  // set our bounding box for the bouncing
  var max_X = 500;
  var max_Y = 260;

  // programmatically generate balls
  var i = 0;
  while (i < numberBalls) {
    generateBalls(i);
    i++;
  }

  //all balls have the same shape, but I randomized size and z-index (because why not?)
  function generateBalls(index) {
    let myBall = document.createElement("div");
    let ballSize = Math.floor(Math.random() * 51) + 25;
    myBall.style.width = ballSize + "px";
    myBall.style.height = myBall.style.width; // we want circles not ovals
    myBall.style.borderRadius = "50%";
    myBall.style.position = "absolute";
    myBall.style.zIndex = Math.ceil(Math.random() * 5);
    myBall.setAttribute("id", "ball" + index); // name each ball element differently
    document.getElementById("balls").appendChild(myBall); // put them in the document
  }

  // create an array of the ball objects, in random spots within our bounding area
  var allballs = [];
  document.getElementById("balls").childNodes.forEach(allBounce); // note that because childNodes generates a node list and not an array, we cannot use the map method
  // it seems inefficient to use both the forEach and the while loop to iterate through the balls - at some future date I may fix it.

  function allBounce(currentValue) {
    let bounce = {
      velocity_x: Math.floor(Math.random() * 10) + 5,
      velocity_y: Math.floor(Math.random() * 10) + 5,
      position_x: Math.floor(Math.random() * max_X),
      position_y: Math.floor(Math.random() * max_Y),
    };
    // bounce is a temporary object - the current ball we're creating.
    allballs.push(bounce); // we add bounce to the array and move on
  }

  function mooveBall(index) {
    let ballInQuestion = document.getElementById("ball" + index);
    // detect edges
    if (
      (allballs[index].position_x > max_X) |
      (allballs[index].position_x < 0)
    ) {
      allballs[index].velocity_x = allballs[index].velocity_x * -1; // change direction
    }
    if (
      (allballs[index].position_y > max_Y) |
      (allballs[index].position_y < 0)
    ) {
      allballs[index].velocity_y = allballs[index].velocity_y * -1; // change direction
      //change the color if it hits the Y-axis edge
      let newColour = Math.floor(Math.random() * 16777215).toString(16); // generates a random hex
      // https://www.binaryhexconverter.com/hex-to-decimal-converter is where I got 16777215 (FFFFFF)
      // based on concept from here https://css-tricks.com/snippets/javascript/random-hex-color/
      ballInQuestion.style.background = "#" + newColour;
      ballInQuestion.style.zIndex = Math.ceil(Math.random() * 5);
    }
    // update the ball's position
    allballs[index].position_x += allballs[index].velocity_x;
    allballs[index].position_y += allballs[index].velocity_y;
    ballInQuestion.style.left = allballs[index].position_x + "px";
    ballInQuestion.style.top = allballs[index].position_y + "px";
  }

  function mooveBalls() {
    // iterate through the various balls
    for (let i = 0; i < allballs.length; i++) {
      mooveBall(i);
    }
  }

  setInterval(mooveBalls, 35); // the lower the delay between moves, the smoother the animation
</script>
